"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[1679],{12274:function(e,t,r){r.d(t,{c:function(){return s}});var n=r(73109);function o(e){return[...n.ds,(0,n.dt)(e)]}function s(e,t){let[r,s]=(0,n.dq)(e),a=(0,n.dr)(o(e),t);return{protocolName:r,payloadName:s,payloadLiteral:e,...(0,n.dr)(n.du,t),...a,hash:(0,n.ap)((0,n.aj)(o(e),a))}}},31679:function(e,t,r){r.r(t),r.d(t,{SuiWormholeCore:function(){return a}});var n=r(73109),o=r(63753),s=r(12274);class a{network;chain;provider;contracts;chainId;coreBridgePackageId;constructor(e,t,r,o){this.network=e,this.chain=t,this.provider=r,this.contracts=o,this.chainId=(0,n.ah)(t);let s=o.coreBridge;if(!s)throw Error(`CoreBridge contract Address for chain ${t} not found`);this.coreBridgePackageId=s}getGuardianSet(e){throw Error("Method not implemented.")}getMessageFee(){throw Error("Method not implemented.")}static async fromRpc(e,t){let[r,n]=await o.k.chainFromRpc(e),s=t[n];if(s.network!==r)throw Error(`Network mismatch: ${s.network} !== ${r}`);return new a(r,n,e,s.contracts)}async *verifyMessage(e,t){throw Error("Method not implemented.")}async *publishMessage(e,t){throw Error("Method not implemented.")}async parseTransaction(e){return(await this.parseMessages(e)).map(e=>({emitter:e.emitterAddress,sequence:e.sequence,chain:this.chain}))}async getGuardianSetIndex(){throw Error("Method not implemented.")}async parseMessages(e){let t=(await this.provider.getTransactionBlock({digest:e,options:{showEvents:!0,showEffects:!0,showInput:!0}})).events?.filter(e=>e.type.endsWith("WormholeMessage"));if(!t||0==t.length)throw Error("WormholeMessage not found");return t.map(e=>{let t=e.parsedJson;return(0,s.c)("Uint8Array",{emitterChain:this.chain,emitterAddress:new o.G(t.sender).toUniversalAddress(),sequence:BigInt(t.sequence),guardianSet:0,timestamp:Number(t.timestamp),consistencyLevel:t.consistency_level,nonce:t.nonce,signatures:[],payload:new Uint8Array(t.payload)})})}}(0,n.au)("Sui","WormholeCore",a)}}]);