"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[4961,1679],{12274:function(e,t,r){r.d(t,{c:function(){return n}});var a=r(73109);function i(e){return[...a.ds,(0,a.dt)(e)]}function n(e,t){let[r,n]=(0,a.dq)(e),o=(0,a.dr)(i(e),t);return{protocolName:r,payloadName:n,payloadLiteral:e,...(0,a.dr)(a.du,t),...o,hash:(0,a.ap)((0,a.aj)(i(e),o))}}},31679:function(e,t,r){r.r(t),r.d(t,{SuiWormholeCore:function(){return o}});var a=r(73109),i=r(63753),n=r(12274);class o{network;chain;provider;contracts;chainId;coreBridgePackageId;constructor(e,t,r,i){this.network=e,this.chain=t,this.provider=r,this.contracts=i,this.chainId=(0,a.ah)(t);let n=i.coreBridge;if(!n)throw Error(`CoreBridge contract Address for chain ${t} not found`);this.coreBridgePackageId=n}getGuardianSet(e){throw Error("Method not implemented.")}getMessageFee(){throw Error("Method not implemented.")}static async fromRpc(e,t){let[r,a]=await i.k.chainFromRpc(e),n=t[a];if(n.network!==r)throw Error(`Network mismatch: ${n.network} !== ${r}`);return new o(r,a,e,n.contracts)}async *verifyMessage(e,t){throw Error("Method not implemented.")}async *publishMessage(e,t){throw Error("Method not implemented.")}async parseTransaction(e){return(await this.parseMessages(e)).map(e=>({emitter:e.emitterAddress,sequence:e.sequence,chain:this.chain}))}async getGuardianSetIndex(){throw Error("Method not implemented.")}async parseMessages(e){let t=(await this.provider.getTransactionBlock({digest:e,options:{showEvents:!0,showEffects:!0,showInput:!0}})).events?.filter(e=>e.type.endsWith("WormholeMessage"));if(!t||0==t.length)throw Error("WormholeMessage not found");return t.map(e=>{let t=e.parsedJson;return(0,n.c)("Uint8Array",{emitterChain:this.chain,emitterAddress:new i.G(t.sender).toUniversalAddress(),sequence:BigInt(t.sequence),guardianSet:0,timestamp:Number(t.timestamp),consistencyLevel:t.consistency_level,nonce:t.nonce,signatures:[],payload:new Uint8Array(t.payload)})})}}(0,a.au)("Sui","WormholeCore",o)},64961:function(e,t,r){r.r(t),r.d(t,{SuiAutomaticTokenBridge:function(){return d},SuiTokenBridge:function(){return s},getTokenCoinType:function(){return o},getTokenFromTokenRegistry:function(){return n}});var a=r(63753);r(31679);var i=r(73109);let n=async(e,t,r)=>{if(!(0,a.ag)(r))throw Error(`Invalid Sui type: ${r}`);let i=await (0,a.aD)(e,t);if(!i)throw Error(`Unable to fetch object fields from token bridge state. Object ID: ${t}`);let n=i.token_registry.fields?.id?.id;if(!n)throw Error("Unable to fetch token registry object ID");let o=(0,a.aE)(i.token_registry?.type);if(!o)throw Error("Unable to fetch token registry package ID");return e.getDynamicFieldObject({parentId:n,name:{type:`${o}::token_registry::Key<${r}>`,value:{dummy_field:!1}}})},o=async(e,t,r,i)=>{let n=await (0,a.aD)(e,t);if(!n)throw Error("Unable to fetch object fields from token bridge state");let o=n.token_registry?.fields?.coin_types,s=o?.fields?.id?.id;if(!s)throw Error("Unable to fetch coin types");let d=(0,a.aF)(o?.type);if(!d)throw Error("Unable to get key type");let c=await e.getDynamicFieldObject({parentId:s,name:{type:d,value:{addr:[...r],chain:i}}});if(c.error){if("dynamicFieldNotFound"===c.error.code)return null;throw Error(`Unexpected getDynamicFieldObject response ${c.error}`)}let l=(0,a.aG)(c);if(!l)return null;if(!(0,a.aH)(l))throw Error("What?");return"value"in l?(0,a.aI)(l.value):null};class s{network;chain;provider;contracts;coreBridgeObjectId;tokenBridgeObjectId;chainId;constructor(e,t,r,a){this.network=e,this.chain=t,this.provider=r,this.contracts=a,this.chainId=i.l.get(e,t);let n=this.contracts.tokenBridge;if(!n)throw Error(`Wormhole Token Bridge contract for domain ${t} not found`);let o=this.contracts.coreBridge;if(!o)throw Error(`Wormhole Token Bridge contract for domain ${t} not found`);this.tokenBridgeObjectId=n,this.coreBridgeObjectId=o}static async fromRpc(e,t){let[r,i]=await a.k.chainFromRpc(e),n=t[i];if(n.network!==r)throw Error(`Network mismatch: ${n.network} != ${r}`);return new s(r,i,e,n.contracts)}async isWrappedAsset(e){try{return await this.getOriginalAsset(e),!0}catch{return!1}}async getOriginalAsset(e){let t=e.getCoinType();if(!(0,a.ag)(t))throw Error(`Invalid Sui type: ${t}`);let r=await n(this.provider,this.tokenBridgeObjectId,t),o=(0,a.aG)(r);if(!o)throw(0,i.di)(t);if(!(0,a.aH)(o))throw Error("Expected fields to be a MoveStruct");if(!("value"in o))throw Error("Expected a `value` key in fields of MoveStruct");let s=o.value;if(!(0,a.aJ)(s))throw Error("Expected fields to be a MoveStruct");let d=(0,a.aI)(s.type);if(t=(0,a.aI)(t),d.includes(`wrapped_asset::WrappedAsset<${t}>`)){let e=s.fields.info;if(!(0,a.aJ)(e))throw Error("Expected fields to be a MoveStruct");let t=e.fields.token_address;if(!(0,a.aJ)(t))throw Error("Expected fields to be a MoveStruct");if(!(0,a.aH)(t.fields))throw Error("Expected address data to be a MoveObject");if(!("value"in t.fields))throw Error("Expected a `value` key in fields of MoveStruct");let r=t.fields.value;if(!(0,a.aJ)(r))throw Error("Expected fields to be a MoveStruct");let n=new Uint8Array(r.fields.data);return{chain:(0,i.L)(Number(e.fields.token_chain)),address:new i.ai(n)}}throw(0,i.di)(t)}async getTokenUniversalAddress(e){let t=e.getCoinType();if(!(0,a.ag)(t))throw Error(`Invalid Sui type: ${t}`);let r=await n(this.provider,this.tokenBridgeObjectId,t),o=(0,a.aG)(r);if(!o)throw Error(`Token of type ${t} has not been registered with the token bridge. Has it been attested?`);if(!(0,a.aH)(o))throw Error("Expected fields to be a MoveStruct");if(!("value"in o))throw Error("Expected a `value` key in fields of MoveStruct");let s=o.value;if(!(0,a.aJ)(s))throw Error("Expected fields to be a MoveStruct");let d=(0,a.aI)(s.type);if(t=(0,a.aI)(t),d.includes(`native_asset::NativeAsset<${t}>`)){let e=s.fields.token_address;if(!(0,a.aJ)(e))throw Error("Expected fields to be a MoveStruct");if(!("value"in e.fields))throw Error("Expected a `value` key in fields of MoveStruct");let t=e.fields.value;if(!(0,a.aJ)(t))throw Error("Expected fields to be a MoveStruct");let r=new Uint8Array(t.fields.data);return new i.ai(r)}throw Error(`Token of type ${t} is not a native asset`)}async getTokenNativeAddress(e,t){let r=await o(this.provider,this.tokenBridgeObjectId,t.toUint8Array(),(0,i.ah)(e));if(!r)throw Error(`Token ${t.toString()} not found in token registry`);return new a.G(r)}async hasWrappedAsset(e){try{return await this.getWrappedAsset(e),!0}catch{}return!1}async getWrappedAsset(e){if((0,i.i)(e.address))throw Error("Token Address required, 'native' literal not supported");let t=await o(this.provider,this.tokenBridgeObjectId,e.address.toUniversalAddress().toUint8Array(),(0,i.ah)(e.chain));if(!t)throw(0,i.di)((0,i.N)(e));return(0,i.t)(this.chain,t)}async isTransferCompleted(e){let t=await (0,a.aD)(this.provider,this.tokenBridgeObjectId);if(!t)throw Error("Unable to fetch object fields from token bridge state");let r=t.consumed_vaas?.fields?.hashes,n=(0,a.aF)(r?.fields?.items?.type);if(!n)throw Error("Unable to get key type");let o=r?.fields?.items?.fields?.id?.id;if(!o)throw Error("Unable to fetch consumed VAAs table");let s=await this.provider.getDynamicFieldObject({parentId:o,name:{type:n,value:{data:[...(0,i.ap)(e.hash)]}}});if(!s.error)return!0;if("dynamicFieldNotFound"===s.error.code)return!1;throw Error(`Unexpected getDynamicFieldObject response ${s.error}`)}async *createAttestation(e){let t=e.toString(),r=await this.provider.getCoinMetadata({coinType:t});if(null===r||null===r.id)throw Error(`Coin metadata ID for type ${t} not found`);let[i,n]=await this.getPackageIds(),o=new a.e,[s]=o.splitCoins(o.gas,[o.pure.u64(0n)]),[d]=o.moveCall({target:`${n}::attest_token::attest_token`,arguments:[o.object(this.tokenBridgeObjectId),o.object(r.id),o.pure.u32(0)],typeArguments:[t]});o.moveCall({target:`${i}::publish_message::publish_message`,arguments:[o.object(this.coreBridgeObjectId),s,d,o.object(a.h)]}),yield this.createUnsignedTx(o,"Sui.TokenBridge.CreateAttestation")}async *submitAttestation(e,t){let[r,n]=await this.getPackageIds(),o=t.toString(),s=Math.min(e.payload.decimals,8),d=await this.getCoinBuildOutput(r,n,s),c=await (0,a.aK)(d,o);yield this.createUnsignedTx(c,"Sui.TokenBridge.PrepareCreateWrapped");let l="",u="",g="",h="",p="",f=!1;for(;!f;)for(let e of(await new Promise(e=>setTimeout(e,500)),(await this.provider.queryTransactionBlocks({filter:{FromAddress:o},options:{showObjectChanges:!0},limit:3})).data))if("objectChanges"in e){for(let t of e.objectChanges)(0,a.aL)(t)&&void 0!==t.packageId?l=t.packageId:(0,a.aM)(t)&&t.objectType.includes("WrappedAssetSetup")?(u=t.objectId,p=t.objectType.split(", ")[1].replace(">","")):(0,a.aM)(t)&&t.objectType.includes("UpgradeCap")?g=t.objectId:(0,a.aM)(t)&&t.objectType.includes("CoinMetadata")&&(h=t.objectId);if(""!==l&&""!==u&&""!==g&&""!==h){f=!0;break}l="",u="",g="",h=""}let m=(0,a.aN)(l),y=new a.e,[w]=y.moveCall({target:`${r}::vaa::parse_and_verify`,arguments:[y.object(this.coreBridgeObjectId),y.pure.vector("u8",(0,i.at)(e)),y.object(a.h)]}),[k]=y.moveCall({target:`${n}::vaa::verify_only_once`,arguments:[y.object(this.tokenBridgeObjectId),w]});y.moveCall({target:`${n}::create_wrapped::complete_registration`,arguments:[y.object(this.tokenBridgeObjectId),y.object(h),y.object(u),y.object(g),k],typeArguments:[m,p]}),yield this.createUnsignedTx(y,"Sui.TokenBridge.SubmitAttestation")}async *transfer(e,t,r,n,o){let s=e.toString(),d=((0,i.i)(r)?a.f:r).toString(),[c,...l]=(await a.k.getCoins(this.provider,e,d)).filter(e=>(0,a.H)(e.coinType,d));if(void 0===c)throw Error(`Coins array doesn't contain any coins of type ${d}`);let[u,g]=await this.getPackageIds(),h=new a.e,[p]=(()=>{if(d===a.f)return h.splitCoins(h.gas,[h.pure.u64(n)]);{let e=h.object(c.coinObjectId);return l.length&&h.mergeCoins(e,l.map(e=>h.object(e.coinObjectId))),h.splitCoins(e,[h.pure.u64(n)])}})(),[f]=h.splitCoins(h.gas,[h.pure.u64(0n)]),[m]=h.moveCall({target:`${g}::state::verified_asset`,arguments:[h.object(this.tokenBridgeObjectId)],typeArguments:[d]});if(o){if(!s)throw Error("senderAddress is required for transfer with payload");let e=!1,r=await (async()=>{let t=await (0,a.aO)(this.provider,u,s);if(null!==t)return h.object(t);{let[t]=h.moveCall({target:`${u}::emitter::new`,arguments:[h.object(this.coreBridgeObjectId)]});return e=!0,t}})(),[n,c]=h.moveCall({target:`${g}::transfer_tokens_with_payload::prepare_transfer`,arguments:[r,m,p,h.pure.u16((0,i.ah)(t.chain)),h.pure.vector("u8",t.address.toUint8Array()),h.pure.vector("u8",o),h.pure.u32(0)],typeArguments:[d]});h.moveCall({target:`${g}::coin_utils::return_nonzero`,arguments:[c],typeArguments:[d]});let[l]=h.moveCall({target:`${g}::transfer_tokens_with_payload::transfer_tokens_with_payload`,arguments:[h.object(this.tokenBridgeObjectId),n],typeArguments:[d]});h.moveCall({target:`${u}::publish_message::publish_message`,arguments:[h.object(this.coreBridgeObjectId),f,l,h.object(a.h)]}),e&&h.transferObjects([r],h.pure.address(s)),yield this.createUnsignedTx(h,"Sui.TokenBridge.TransferWithPayload")}else{let[e,r]=h.moveCall({target:`${g}::transfer_tokens::prepare_transfer`,arguments:[m,p,h.pure.u16((0,i.ah)(t.chain)),h.pure.vector("u8",t.address.toUint8Array()),h.pure.u64(0n),h.pure.u32(0)],typeArguments:[d]});h.moveCall({target:`${g}::coin_utils::return_nonzero`,arguments:[r],typeArguments:[d]});let[n]=h.moveCall({target:`${g}::transfer_tokens::transfer_tokens`,arguments:[h.object(this.tokenBridgeObjectId),e],typeArguments:[d]});h.moveCall({target:`${u}::publish_message::publish_message`,arguments:[h.object(this.coreBridgeObjectId),f,n,h.object(a.h)]}),yield this.createUnsignedTx(h,"Sui.TokenBridge.Transfer")}}async *redeem(e,t,r=!0){let n=await o(this.provider,this.tokenBridgeObjectId,t.payload.token.address.toUint8Array(),(0,i.ah)(t.payload.token.chain));if(!n)throw Error("Unable to fetch token coinType");let[s,d]=await this.getPackageIds(),c=new a.e,[l]=c.moveCall({target:`${s}::vaa::parse_and_verify`,arguments:[c.object(this.coreBridgeObjectId),c.pure.vector("u8",(0,i.at)(t)),c.object(a.h)]}),[u]=c.moveCall({target:`${d}::vaa::verify_only_once`,arguments:[c.object(this.tokenBridgeObjectId),l]}),[g]=c.moveCall({target:`${d}::complete_transfer::authorize_transfer`,arguments:[c.object(this.tokenBridgeObjectId),u],typeArguments:[n]}),[h]=c.moveCall({target:`${d}::complete_transfer::redeem_relayer_payout`,arguments:[g],typeArguments:[n]});c.moveCall({target:`${d}::coin_utils::return_nonzero`,arguments:[h],typeArguments:[n]}),yield this.createUnsignedTx(c,"Sui.TokenBridge.Redeem")}async getWrappedNative(){return(0,i.t)(this.chain,a.f)}async getPackageIds(){return Promise.all([(0,a.aP)(this.provider,this.coreBridgeObjectId),(0,a.aP)(this.provider,this.tokenBridgeObjectId)])}async getCoinBuildOutput(e,t,r){if(r>8)throw Error("Decimals is capped at 8");let n=(await a.aQ(this.provider,this.tokenBridgeObjectId))?.replace("0x","");if(!n)throw Error(`Original token bridge package ID not found for object ID ${this.tokenBridgeObjectId}`);let o="a11ceb0b060000000901000a020a14031e1704350405392d07669f01088502600ae502050cea02160004010b010c0205020d000002000201020003030c020001000104020700000700010001090801010c020a050600030803040202000302010702080007080100020800080303090002070801010b020209000901010608010105010b0202080008030209000504434f494e095478436f6e7465787408565f5f305f325f3011577261707065644173736574536574757004636f696e0e6372656174655f777261707065640b64756d6d795f6669656c6404696e697414707265706172655f726567697374726174696f6e0f7075626c69635f7472616e736665720673656e646572087472616e736665720a74785f636f6e746578740f76657273696f6e5f636f6e74726f6c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002"+n+"00020106010000000001090b0031"+r.toString(16).padStart(2,"0")+"0a0138000b012e110238010200";return{modules:[i.ar.encode(i.m.decode(o))],dependencies:["0x1","0x2",t,e].map(e=>(0,a.aR)(e))}}createUnsignedTx(e,t,r=!1){return new a.m(e,this.network,this.chain,t,r)}}class d{network;chain;connection;contracts;tokenBridgeRelayerObjectId;coreBridgeObjectId;tokenBridgeObjectId;fields;constructor(e,t,r,a){this.network=e,this.chain=t,this.connection=r,this.contracts=a;let{tokenBridge:i,tokenBridgeRelayer:n,coreBridge:o}=a;if(!i||!n||!o)throw Error(`Some object IDs for ${t} Automatic Token Bridge not found`);this.tokenBridgeRelayerObjectId=n,this.tokenBridgeObjectId=i,this.coreBridgeObjectId=o}static async fromRpc(e,t){let[r,i]=await a.k.chainFromRpc(e),n=t[i];if(n.network!==r)throw Error(`Network mismatch for chain ${i}: ${n.network} != ${r}`);return new d(r,i,e,n.contracts)}async *transfer(e,t,r,n,o){let s=new a.G((0,i.i)(r)?a.k.nativeTokenId(this.network,this.chain).address:r).getCoinType(),{coreBridge:d,tokenBridge:c}=await this.getPackageIds(),l=new a.e,u=BigInt(0),[g]=l.splitCoins(l.gas,[l.pure.u64(u)]),[h]=await (async()=>{if((0,i.i)(r))return l.splitCoins(l.gas,[l.pure.u64(n)]);{let[t,...r]=(await a.k.getCoins(this.connection,e,s)).filter(e=>e.coinType===s);if(void 0===t)throw Error(`Coins array doesn't contain any coins of type ${s}`);let i=l.object(t.coinObjectId);return r.length&&l.mergeCoins(i,r.map(e=>l.object(e.coinObjectId))),l.splitCoins(i,[l.pure.u64(n)])}})(),[p]=l.moveCall({target:`${c}::state::verified_asset`,arguments:[l.object(this.tokenBridgeObjectId)],typeArguments:[s]}),f=await this.getPackageId(),[m]=l.moveCall({target:`${f}::transfer::transfer_tokens_with_relay`,arguments:[l.object(this.tokenBridgeRelayerObjectId),h,p,l.pure.u64(o??0n),l.pure.u16((0,i.ah)(t.chain)),l.pure.address(i.m.encode(t.address.toUint8Array(),!0)),l.pure.u32(123)],typeArguments:[s]}),[y]=l.moveCall({target:`${c}::transfer_tokens_with_payload::transfer_tokens_with_payload`,arguments:[l.object(this.tokenBridgeObjectId),m],typeArguments:[s]});l.moveCall({target:`${d}::publish_message::publish_message`,arguments:[l.object(this.coreBridgeObjectId),g,y,l.object(a.h)]}),yield this.createUnsignedTx(l,"AutomaticTokenBridge.transfer")}async *redeem(e,t){let{coreBridge:r,tokenBridge:n}=await this.getPackageIds(),{address:s,chain:d}=t.payload.token,c=await o(this.connection,this.tokenBridgeObjectId,s.toUniversalAddress().toUint8Array(),(0,i.ah)(d));if(!c)throw Error("Unable to fetch token coinType");let l=new a.e,[u]=l.moveCall({target:`${r}::vaa::parse_and_verify`,arguments:[l.object(this.coreBridgeObjectId),l.pure.vector("u8",(0,i.at)(t)),l.object(a.h)]}),[g]=l.moveCall({target:`${n}::vaa::verify_only_once`,arguments:[l.object(this.tokenBridgeObjectId),u]}),[h]=l.moveCall({target:`${n}::complete_transfer_with_payload::authorize_transfer`,arguments:[l.object(this.tokenBridgeObjectId),g],typeArguments:[c]}),p=await this.getPackageId();l.moveCall({target:`${p}::redeem::complete_transfer`,arguments:[l.object(this.tokenBridgeRelayerObjectId),h],typeArguments:[c]}),yield this.createUnsignedTx(l,"AutomaticTokenBridge.redeem")}async getRelayerFee(e,t){let r=(0,i.i)(t)?a.k.nativeTokenId(this.network,this.chain):t,n=await this.getTokenInfo(r.toString());if(null===n)throw Error("Unsupported token for relay");let o=await this.getFields(),s=await this.connection.getDynamicFieldObject({parentId:this.tokenBridgeRelayerObjectId,name:{type:"vector<u8>",value:Array.from(i.an.encode("relayer_fees"))}});if(!s.data||!s.data.content)throw s.error?Error("Failed to get relayer fees: "+JSON.stringify(s.error)):Error("Unable to compute relayer fee");let{content:d}=s.data;if(!(0,a.aJ)(d)||!(0,a.aS)(d.fields.id))throw Error("Unable to compute relayer fee");let c=await this.connection.getDynamicFieldObject({parentId:d.fields.id.id,name:{type:"u16",value:(0,i.ah)(e)}});if(!c.data||!c.data.content)throw c.error?Error("Failed to get relayer fees: "+JSON.stringify(s.error)):Error("Unable to compute relayer fee");let{content:l}=c.data;if(!(0,a.aJ)(l))throw Error("Unable to compute relayer fee");let u=await a.k.getDecimals(this.network,this.chain,this.connection,t.toString()),g=n.swap_rate,h=o.relayer_fee_precision,p=o.swap_rate_precision,f=l.fields.value;return 10n**BigInt(u)*BigInt(f)*BigInt(p)/(BigInt(g)*BigInt(h))}async maxSwapAmount(e){let t=((0,i.i)(e)?a.k.nativeTokenId(this.network,this.chain):e).toString(),r=await this.connection.getCoinMetadata({coinType:t});if(!r)throw Error("metadata is null");let n=await this.getPackageId(),o=new a.e;o.moveCall({target:`${n}::redeem::calculate_max_swap_amount_in`,arguments:[o.object(this.tokenBridgeRelayerObjectId),o.pure.u8(r.decimals)],typeArguments:[t]});let s=await this.connection.devInspectTransactionBlock({transactionBlock:o,sender:i.m.encode(new Uint8Array(32))});if(!s.results||0==s.results.length||!s.results[0]?.returnValues||s.results[0]?.returnValues.length!==1)throw Error("swap rate not set");return i.ao.decode(new Uint8Array(s.results[0].returnValues[0][0].toReversed()))}async nativeTokenAmount(e,t){let r=((0,i.i)(e)?a.k.nativeTokenId(this.network,this.chain):e).toString(),n=await this.connection.getCoinMetadata({coinType:r});if(!n)throw Error("metadata is null");let o=await this.getPackageId(),s=new a.e;s.moveCall({target:`${o}::redeem::calculate_native_swap_amount_out`,arguments:[s.object(this.tokenBridgeRelayerObjectId),s.pure.u64(t),s.pure.u8(n.decimals)],typeArguments:[r]});let d=await this.connection.devInspectTransactionBlock({transactionBlock:s,sender:i.m.encode(new Uint8Array(32))});if(!d.results||0==d.results.length||!d.results[0]?.returnValues||d.results[0]?.returnValues.length!==1)throw Error("swap rate not set");return i.ao.decode(new Uint8Array(d.results[0].returnValues[0][0].toReversed()))}async getRegisteredTokens(){let e=(await this.getFields()).registered_tokens.fields.id.id;return(await this.connection.getDynamicFields({parentId:e})).data.map(e=>{let{address:t,module:r,name:i}=(0,a.aT)(e.objectType);return new a.G([t,r,i].join(a.aU))})}async isRegisteredToken(e){let t=new a.G((0,i.i)(e)?a.k.nativeTokenId(this.network,this.chain).address:e).unwrap();try{return await this.getTokenInfo(t)!==null}catch(e){console.error(e)}return!1}async getTokenInfo(e){let t=await this.getFields(),r=new a.G(t.registered_tokens.type).getPackageId(),i=t.registered_tokens.fields.id.id,n=new a.G(e),o=(0,a.H)(a.aV,n.unwrap())?a.aV:n.getCoinType();try{let e=await this.connection.getDynamicFieldObject({parentId:i,name:{type:`${r}::registered_tokens::Key<${o}>`,value:{dummy_field:!1}}});if(e.error)throw Error("Failed to get token info: "+JSON.stringify(e.error));if(!e.data||!e.data.content)throw Error("Failed to get token info: "+JSON.stringify(e));let{content:t}=e.data;return(0,a.aJ)(t)&&(0,a.aJ)(t.fields.value)?t.fields.value.fields:null}catch(e){if(e?.code===-32e3&&e.message?.includes("RPC Error"))return console.error(e),null;throw e}}async getFields(){if(!this.fields){let e=await (0,a.aD)(this.connection,this.tokenBridgeRelayerObjectId);if(null===e)throw Error("Failed to get fields from token bridge relayer state");this.fields=e}return this.fields}async getPackageId(){let e=await this.getFields();return new a.G(e.registered_tokens.type).getPackageId()}async getPackageIds(){let[e,t]=await Promise.all([(0,a.aP)(this.connection,this.coreBridgeObjectId),(0,a.aP)(this.connection,this.tokenBridgeObjectId)]);return{coreBridge:e,tokenBridge:t}}createUnsignedTx(e,t,r=!1){return new a.m(e,this.network,this.chain,t,r)}}(0,i.au)("Sui","TokenBridge",s),(0,i.au)("Sui","AutomaticTokenBridge",d)}}]);