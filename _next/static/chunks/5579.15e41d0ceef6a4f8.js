"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[5579],{45579:function(e,t,n){n.r(t),n.d(t,{AptosTokenBridge:function(){return h}});var s=n(73109),r=n(84321),a=n(75359),i=n(35493),o=n(59066);let d=[{name:"tokenBridgeAddress",...s.aI},{name:"chain",...(0,s.ax)()},{name:"domainSeparator",binary:"bytes",custom:s.an.encode(r.e),omit:!0},{name:"tokenId",...s.aI},{name:"domainSeparator",binary:"bytes",custom:new Uint8Array([255]),omit:!0}],c=e=>(0,s.aj)(d,e);class h{network;chain;connection;contracts;chainId;tokenBridgeAddress;constructor(e,t,n,r){this.network=e,this.chain=t,this.connection=n,this.contracts=r,this.chainId=(0,s.ah)(t);let a=r.tokenBridge;if(!a)throw Error(`TokenBridge contract Address for chain ${t} not found`);this.tokenBridgeAddress=a}static async fromRpc(e,t){let[n,s]=await i.A.chainFromRpc(e),r=t[s];if(r.network!==n)throw Error("Network mismatch "+r.network+" !== "+n);return new h(n,s,e,r.contracts)}async isWrappedAsset(e){try{return await this.getOriginalAsset(e),!0}catch{return!1}}async getOriginalAsset(e){let t=e.toString().split(r.e),n=null;try{n=await this.connection.getAccountResource({accountAddress:t[0],resourceType:`${this.tokenBridgeAddress}::state::OriginInfo`})}catch(t){throw t instanceof a.T&&t.data?.error_code==="resource_not_found"?(0,s.di)(e.toString()):t}if(!n)throw(0,s.di)(e.toString());return{chain:(0,s.L)(parseInt(n.token_chain.number)),address:new s.ai(n.token_address.external_address)}}async getTokenUniversalAddress(e){return new s.ai(s.m.encode((0,s.cc)(e.toString()),!0))}async getTokenNativeAddress(e,t){let n=e===this.chain?await this.getTypeFromExternalAddress(t.toString()):await this.getAssetFullyQualifiedType({chain:e,address:t});if(!n)throw Error("Invalid asset address.");return new r.A(n)}async hasWrappedAsset(e){try{return await this.getWrappedAsset(e),!0}catch{}return!1}async getWrappedAsset(e){if((0,s.i)(e.address))throw Error("native asset cannot be a wrapped asset");let t=await this.getAssetFullyQualifiedType(e);if(!t)throw Error("Invalid asset address.");return await this.connection.getAccountResource({accountAddress:(0,r.f)(t),resourceType:`${this.tokenBridgeAddress}::state::OriginInfo`}),(0,s.t)(this.chain,t)}async isTransferCompleted(e){let t=(await this.connection.getAccountResource({accountAddress:this.tokenBridgeAddress,resourceType:`${this.tokenBridgeAddress}::state::State`})).consumed_vaas.elems.handle;try{return await this.connection.getTableItem({handle:t,data:{key_type:"vector<u8>",value_type:"u8",key:`0x${s.C.from((0,s.ap)(e.hash)).toString("hex")}`}}),!0}catch{return!1}}async getWrappedNative(){return(0,s.t)(this.chain,r.d)}async *createAttestation(e,t){let n={chain:this.chain,address:new r.A(e)},s=await this.getAssetFullyQualifiedType(n);if(!s)throw Error("Invalid asset address.");yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::attest_token::attest_token_entry`,typeArguments:[s],functionArguments:[]},"Aptos.AttestToken")}async *submitAttestation(e,t){yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::wrapped::create_wrapped_coin_type`,typeArguments:[],functionArguments:[(0,s.at)(e)]},"Aptos.CreateWrappedCoinType");let n=await this.getAssetFullyQualifiedType(e.payload.token);if(!n)throw Error("Invalid asset address.");yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::wrapped::create_wrapped_coin`,typeArguments:[n],functionArguments:[(0,s.at)(e)]},"Aptos.CreateWrappedCoin")}async *transfer(e,t,n,a,i){let o=(0,s.i)(n)?r.d:n.toString(),d=t.address.toUniversalAddress().toUint8Array(),c=(0,s.ah)(t.chain);i?yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::transfer_tokens::transfer_tokens_with_payload_entry`,typeArguments:[o],functionArguments:[a,c,d,0n,i]},"Aptos.TransferTokensWithPayload"):yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::transfer_tokens::transfer_tokens_entry`,typeArguments:[o],functionArguments:[a,c,d,0n,0n]},"Aptos.TransferTokens")}async *redeem(e,t,n=!0){let r=t.payload.token.chain===this.chain?await this.getTypeFromExternalAddress(t.payload.token.address.toString()):await this.getAssetFullyQualifiedType(t.payload.token);if(!r)throw Error("Invalid asset address.");yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::complete_transfer::submit_vaa_and_register_entry`,typeArguments:[r],functionArguments:[(0,s.at)(t)]},"Aptos.CompleteTransfer")}async getAssetFullyQualifiedType(e){return e.chain===this.chain?(0,r.i)(e.address.toString())?e.address.toString():null:`${h.getForeignAssetAddress(this.chain,this.tokenBridgeAddress,e)}::coin::T`}async getTypeFromExternalAddress(e){try{let{handle:t}=(await this.connection.getAccountResource({accountAddress:this.tokenBridgeAddress,resourceType:`${this.tokenBridgeAddress}::state::State`})).native_infos,n=await this.connection.getTableItem({handle:t,data:{key_type:`${this.tokenBridgeAddress}::token_hash::TokenHash`,value_type:"0x1::type_info::TypeInfo",key:{hash:e}}});return n?[n.account_address,String.fromCharCode(...s.m.decode(n.module_name)),String.fromCharCode(...s.m.decode(n.struct_name))].join(r.e):null}catch{return null}}static getForeignAssetAddress(e,t,n){if((0,s.i)(n.address))throw Error("Invalid token address");let a=c({chain:n.chain,tokenBridgeAddress:new r.A(t).toUniversalAddress(),tokenId:n.address.toUniversalAddress()});return s.m.encode((0,s.cc)(a),!0)}createUnsignedTx(e,t,n=!1){return new o.A(e,this.network,this.chain,t,n)}}(0,s.au)("Aptos","TokenBridge",h)},59066:function(e,t,n){n.d(t,{A:function(){return s}});class s{transaction;network;chain;description;parallelizable;constructor(e,t,n,s,r=!1){this.transaction=e,this.network=t,this.chain=n,this.description=s,this.parallelizable=r}}}}]);