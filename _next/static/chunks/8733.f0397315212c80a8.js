"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[8733,165],{36533:function(t,e,n){n.r(e),n.d(e,{default:function(){return h}});var a=n(35493),r=n(75359),i=n(73109),s=n(84321);async function o(t,e){let[n,s]=await a.A.chainFromRpc(t);return new c(s,r.v.fromPrivateKey({privateKey:new r.z(i.m.decode(e))}),t)}class c{_chain;_account;_rpc;_debug;constructor(t,e,n,a){this._chain=t,this._account=e,this._rpc=n,this._debug=a}chain(){return this._chain}address(){return this._account.accountAddress.toString()}async signAndSend(t){let e=[];for(let n of t){let{description:t,transaction:a}=n;this._debug&&console.log(`Signing: ${t} for ${this.address()}`);let r=await this._rpc.transaction.build.simple({sender:this._account.accountAddress,data:a}),{hash:i}=await this._simSignSend(r);e.push(i)}return e}async _simSignSend(t){return await this._rpc.transaction.simulate.simple({signerPublicKey:this._account.publicKey,transaction:t}).then(t=>t.forEach(t=>{if(!t.success)throw Error(`Transaction failed: ${t.vm_status}
${JSON.stringify(t,null,2)}`)})),this._rpc.signAndSubmitTransaction({signer:this._account,transaction:t}).then(t=>this._rpc.waitForTransaction({transactionHash:t.hash}))}}let h={Address:s.A,Platform:a.A,getSigner:o,protocols:{WormholeCore:()=>n.e(4422).then(n.bind(n,64422)),TokenBridge:()=>n.e(5579).then(n.bind(n,45579)),CircleBridge:()=>n.e(5592).then(n.bind(n,55592))},getChain:(t,e,n)=>new a.a(e,new a.A(t,(0,i.ci)(t,s._,{[e]:n})))}},70165:function(t,e,n){n.d(e,{j:function(){return r}});class a extends Error{}function r(t,e){let n;if("string"!=typeof t)throw new a("Invalid token specified: must be a string");e||(e={});let r=!0===e.header?0:1,i=t.split(".")[r];if("string"!=typeof i)throw new a(`Invalid token specified: missing part #${r+1}`);try{n=function(t){let e=t.replace(/-/g,"+").replace(/_/g,"/");switch(e.length%4){case 0:break;case 2:e+="==";break;case 3:e+="=";break;default:throw Error("base64 string is not of the correct length")}try{var n;return n=e,decodeURIComponent(atob(n).replace(/(.)/g,(t,e)=>{let n=e.charCodeAt(0).toString(16).toUpperCase();return n.length<2&&(n="0"+n),"%"+n}))}catch{return atob(e)}}(i)}catch(t){throw new a(`Invalid token specified: invalid base64 for part #${r+1} (${t.message})`)}try{return JSON.parse(n)}catch(t){throw new a(`Invalid token specified: invalid json for part #${r+1} (${t.message})`)}}a.prototype.name="InvalidTokenError"},35493:function(t,e,n){n.d(e,{A:function(){return o},a:function(){return s}});var a=n(75359),r=n(73109),i=n(84321);class s extends r.bY{}class o extends r.bZ{static _platform=i._;constructor(t,e){super(t,e??(0,r.b_)(t,o._platform))}getRpc(t){if(t in this.config){let e="Mainnet"===this.network?a.e.MAINNET:a.e.TESTNET,n=new a.u({fullnode:this.config[t].rpc,network:e});return new a.W(n)}throw Error("No configuration available for chain: "+t)}getChain(t,e){if(t in this.config)return new s(t,this);throw Error("No configuration available for chain: "+t)}static nativeTokenId(t,e){if(!this.isSupportedChain(e))throw Error(`invalid chain: ${e}`);return r.W.tokenId(e,i.d)}static isNativeTokenId(t,e,n){return!!this.isSupportedChain(e)&&n.chain===e&&this.nativeTokenId(t,e)==n}static isSupportedChain(t){return(0,r.d)(t)===o._platform}static async getDecimals(t,e,n,a){if((0,r.i)(a)||a===i.d)return(0,r.b$)(o._platform);let s=a.toString();return(await n.getFungibleAssetMetadataByAssetType({assetType:s})).decimals}static async getBalance(t,e,n,a,s){let o=(0,r.i)(s)?i.d:s.toString();try{return(await n.getCurrentFungibleAssetBalances({options:{where:{owner_address:{_eq:a},asset_type:{_eq:o}}}}))[0]?.amount??null}catch(t){if(404===t.status)return null;throw t}}static async getBalances(t,e,n,a){try{let t=await n.getCurrentFungibleAssetBalances({options:{where:{owner_address:{_eq:a}}}}),e={};for(let n of t)n.asset_type&&(e["0x1::aptos_coin::AptosCoin"===n.asset_type?"native":n.asset_type]=n.amount);return e}catch(t){if(404===t.status)return{};throw t}}static async sendWait(t,e,n){let a=[];for(let t of n){let n=await e.transaction.submit.simple(t.transaction),r=await e.waitForTransaction({transactionHash:n.hash});a.push(r.hash)}return a}static async getLatestBlock(t){return Number((await t.getLedgerInfo()).block_height)}static async getLatestFinalizedBlock(t){return Number((await t.getLedgerInfo()).block_height)}static chainFromChainId(t){let e=(0,r.c0)(o._platform,BigInt(t));if(!e)throw Error(`No matching chainId to determine network and chain: ${t}`);let[n,a]=e;return[n,a]}static async chainFromRpc(t){let e=await t.getLedgerInfo();return this.chainFromChainId(e.chain_id.toString())}}}}]);