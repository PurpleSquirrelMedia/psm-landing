"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[4422],{12274:function(e,t,r){r.d(t,{c:function(){return a}});var n=r(73109);function o(e){return[...n.ds,(0,n.dt)(e)]}function a(e,t){let[r,a]=(0,n.dq)(e),s=(0,n.dr)(o(e),t);return{protocolName:r,payloadName:a,payloadLiteral:e,...(0,n.dr)(n.du,t),...s,hash:(0,n.ap)((0,n.aj)(o(e),s))}}},64422:function(e,t,r){r.r(t),r.d(t,{AptosWormholeCore:function(){return s}});var n=r(73109),o=r(35493),a=r(12274);class s{network;chain;connection;contracts;chainId;coreBridge;constructor(e,t,r,o){this.network=e,this.chain=t,this.connection=r,this.contracts=o,this.chainId=(0,n.ah)(t);let a=o.coreBridge;if(!a)throw Error(`CoreBridge contract Address for chain ${t} not found`);this.coreBridge=a}getGuardianSet(e){throw Error("Method not implemented.")}getGuardianSetIndex(){throw Error("Method not implemented.")}getMessageFee(){throw Error("Method not implemented.")}static async fromRpc(e,t){let[r,n]=await o.A.chainFromRpc(e),a=t[n];if(a.network!==r)throw Error(`Network mismatch: ${a.network} !== ${r}`);return new s(r,n,e,a.contracts)}async *publishMessage(e,t){throw Error("Method not implemented.")}async *verifyMessage(e,t){throw Error("Not implemented.")}async parseTransaction(e){return(await this.parseMessages(e)).map(e=>({chain:e.emitterChain,emitter:e.emitterAddress,sequence:e.sequence}))}async parseMessages(e){let t=await this.connection.getTransactionByHash({transactionHash:e});if("user_transaction"!==t.type)throw Error(`${e} is not a user_transaction`);let r=t.events.filter(e=>e.type.endsWith("WormholeMessage"));if(!r||0===r.length)throw Error(`WormholeMessage not found for ${e}`);return r.map(e=>{let t=e.data,r=new n.ai(BigInt(t.sender).toString(16).padStart(64,"0"));return(0,a.c)("Uint8Array",{guardianSet:0,emitterChain:this.chain,emitterAddress:r,sequence:BigInt(t.sequence),timestamp:Number(t.timestamp),consistencyLevel:t.consistency_level,nonce:Number(t.nonce),signatures:[],payload:n.m.decode(t.payload)})})}}(0,n.au)("Aptos","WormholeCore",s)}}]);