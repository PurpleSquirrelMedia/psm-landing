<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scroll 3D Scene - Purple Squirrel Media</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html { scroll-behavior: smooth; }
        body {
            background: #0a0a0f;
            font-family: 'Segoe UI', system-ui, sans-serif;
            color: white;
        }
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1;
            pointer-events: none;
        }
        .scroll-container {
            position: relative;
            z-index: 10;
        }
        section {
            min-height: 100vh;
            display: flex;
            align-items: center;
            padding: 4rem;
        }
        .section-content {
            max-width: 500px;
        }
        section:nth-child(odd) .section-content {
            margin-left: auto;
            text-align: right;
        }
        h2 {
            font-size: clamp(2rem, 5vw, 3.5rem);
            font-weight: 800;
            margin-bottom: 1rem;
            opacity: 0;
            transform: translateY(50px);
            transition: all 0.8s ease;
        }
        h2 span {
            background: linear-gradient(135deg, #8b5cf6, #d946ef);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        p {
            font-size: 1.125rem;
            color: rgba(255,255,255,0.7);
            line-height: 1.8;
            opacity: 0;
            transform: translateY(30px);
            transition: all 0.8s ease 0.2s;
        }
        section.visible h2,
        section.visible p {
            opacity: 1;
            transform: translateY(0);
        }
        .hero {
            justify-content: center;
            text-align: center;
        }
        .hero .section-content {
            max-width: 800px;
            margin: 0 auto;
        }
        .hero h1 {
            font-size: clamp(3rem, 10vw, 6rem);
            font-weight: 900;
            background: linear-gradient(135deg, #8b5cf6, #d946ef, #06b6d4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 1rem;
        }
        .scroll-indicator {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            opacity: 0.5;
            animation: bounce 2s infinite;
            z-index: 20;
        }
        @keyframes bounce {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(10px); }
        }
        .scroll-indicator svg {
            width: 24px;
            height: 24px;
            fill: white;
        }
        .progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            height: 3px;
            background: linear-gradient(90deg, #8b5cf6, #d946ef);
            z-index: 100;
            transform-origin: left;
            transform: scaleX(0);
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="progress-bar" id="progressBar"></div>

    <div class="scroll-container">
        <section class="hero">
            <div class="section-content">
                <h1>Purple Squirrel</h1>
                <p style="font-size: 1.5rem; color: rgba(255,255,255,0.8);">
                    Scroll to explore the future of streaming
                </p>
            </div>
        </section>

        <section>
            <div class="section-content">
                <h2>Stream <span>Anywhere</span></h2>
                <p>Access your content from any device, anywhere in the world. Our decentralized network ensures blazing fast delivery with zero buffering.</p>
            </div>
        </section>

        <section>
            <div class="section-content">
                <h2><span>Own</span> Your Media</h2>
                <p>NFT-powered ownership means your purchases are truly yours. Trade, sell, or keep forever - it's your choice.</p>
            </div>
        </section>

        <section>
            <div class="section-content">
                <h2>Create & <span>Earn</span></h2>
                <p>Upload your content and earn directly from your audience. No middlemen, no gatekeepers - just pure creator economy.</p>
            </div>
        </section>

        <section>
            <div class="section-content">
                <h2><span>Community</span> First</h2>
                <p>Join thousands of creators and viewers building the future of entertainment together. Your voice matters here.</p>
            </div>
        </section>

        <section class="hero">
            <div class="section-content">
                <h2>Ready to <span>Start</span>?</h2>
                <p>Join the revolution in decentralized media streaming.</p>
                <button style="margin-top: 2rem; background: linear-gradient(135deg, #8b5cf6, #7c3aed); color: white; padding: 1rem 3rem; border: none; border-radius: 50px; font-size: 1.125rem; font-weight: 600; cursor: pointer;">
                    Get Started Free
                </button>
            </div>
        </section>
    </div>

    <div class="scroll-indicator" id="scrollIndicator">
        <span>Scroll</span>
        <svg viewBox="0 0 24 24"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/></svg>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const canvas = document.getElementById('canvas');
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        // Create floating objects for each section
        const objects = [];
        const objectGroup = new THREE.Group();

        // Materials
        const purpleMat = new THREE.MeshStandardMaterial({
            color: 0x8b5cf6,
            roughness: 0.3,
            metalness: 0.8
        });
        const pinkMat = new THREE.MeshStandardMaterial({
            color: 0xd946ef,
            roughness: 0.3,
            metalness: 0.8
        });
        const cyanMat = new THREE.MeshStandardMaterial({
            color: 0x06b6d4,
            roughness: 0.3,
            metalness: 0.8
        });

        // Section 0: Hero - Floating rings
        const heroGroup = new THREE.Group();
        for (let i = 0; i < 3; i++) {
            const ring = new THREE.Mesh(
                new THREE.TorusGeometry(1 + i * 0.5, 0.05, 16, 100),
                [purpleMat, pinkMat, cyanMat][i]
            );
            ring.rotation.x = Math.random() * Math.PI;
            ring.rotation.y = Math.random() * Math.PI;
            heroGroup.add(ring);
        }
        heroGroup.position.set(0, 0, 0);
        objects.push({ mesh: heroGroup, baseY: 0, section: 0 });
        objectGroup.add(heroGroup);

        // Section 1: Globe/Sphere
        const globeGroup = new THREE.Group();
        const globe = new THREE.Mesh(
            new THREE.IcosahedronGeometry(1, 2),
            new THREE.MeshStandardMaterial({
                color: 0x8b5cf6,
                wireframe: true,
                transparent: true,
                opacity: 0.8
            })
        );
        const globeCore = new THREE.Mesh(
            new THREE.SphereGeometry(0.7, 32, 32),
            purpleMat
        );
        globeGroup.add(globe);
        globeGroup.add(globeCore);
        globeGroup.position.set(-3, -8, 0);
        objects.push({ mesh: globeGroup, baseY: -8, section: 1 });
        objectGroup.add(globeGroup);

        // Section 2: NFT Box
        const nftGroup = new THREE.Group();
        const nftBox = new THREE.Mesh(
            new THREE.BoxGeometry(1.5, 1.5, 1.5),
            pinkMat
        );
        const nftFrame = new THREE.Mesh(
            new THREE.BoxGeometry(1.7, 1.7, 1.7),
            new THREE.MeshStandardMaterial({
                color: 0xd946ef,
                wireframe: true
            })
        );
        nftGroup.add(nftBox);
        nftGroup.add(nftFrame);
        nftGroup.position.set(3, -16, 0);
        objects.push({ mesh: nftGroup, baseY: -16, section: 2 });
        objectGroup.add(nftGroup);

        // Section 3: Coins/Tokens
        const coinsGroup = new THREE.Group();
        for (let i = 0; i < 5; i++) {
            const coin = new THREE.Mesh(
                new THREE.CylinderGeometry(0.5, 0.5, 0.1, 32),
                cyanMat
            );
            coin.position.set(
                Math.sin(i * Math.PI * 0.4) * 1.5,
                Math.cos(i * Math.PI * 0.4) * 1.5,
                i * 0.2
            );
            coin.rotation.x = Math.PI / 2;
            coinsGroup.add(coin);
        }
        coinsGroup.position.set(-3, -24, 0);
        objects.push({ mesh: coinsGroup, baseY: -24, section: 3 });
        objectGroup.add(coinsGroup);

        // Section 4: Community - Connected nodes
        const communityGroup = new THREE.Group();
        const nodePositions = [
            [0, 0, 0], [1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0],
            [0, 1.5, 0.5], [0, -1.5, 0.5]
        ];
        nodePositions.forEach((pos, i) => {
            const node = new THREE.Mesh(
                new THREE.SphereGeometry(0.2, 16, 16),
                i === 0 ? purpleMat : pinkMat
            );
            node.position.set(...pos);
            communityGroup.add(node);
        });
        // Connection lines
        const lineMat = new THREE.LineBasicMaterial({ color: 0x8b5cf6, transparent: true, opacity: 0.5 });
        for (let i = 1; i < nodePositions.length; i++) {
            const points = [
                new THREE.Vector3(...nodePositions[0]),
                new THREE.Vector3(...nodePositions[i])
            ];
            const lineGeom = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(lineGeom, lineMat);
            communityGroup.add(line);
        }
        communityGroup.position.set(3, -32, 0);
        objects.push({ mesh: communityGroup, baseY: -32, section: 4 });
        objectGroup.add(communityGroup);

        // Section 5: CTA - Rocket
        const rocketGroup = new THREE.Group();
        const rocketBody = new THREE.Mesh(
            new THREE.ConeGeometry(0.5, 2, 32),
            purpleMat
        );
        const rocketFin1 = new THREE.Mesh(
            new THREE.BoxGeometry(0.1, 0.5, 0.5),
            pinkMat
        );
        rocketFin1.position.set(0.3, -0.7, 0);
        const rocketFin2 = rocketFin1.clone();
        rocketFin2.position.set(-0.3, -0.7, 0);
        rocketGroup.add(rocketBody);
        rocketGroup.add(rocketFin1);
        rocketGroup.add(rocketFin2);
        rocketGroup.position.set(0, -40, 0);
        rocketGroup.rotation.z = -0.2;
        objects.push({ mesh: rocketGroup, baseY: -40, section: 5 });
        objectGroup.add(rocketGroup);

        scene.add(objectGroup);

        // Lights
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);

        const light1 = new THREE.PointLight(0x8b5cf6, 2, 20);
        light1.position.set(5, 5, 5);
        scene.add(light1);

        const light2 = new THREE.PointLight(0xd946ef, 2, 20);
        light2.position.set(-5, -5, 5);
        scene.add(light2);

        // Particles
        const particleCount = 2000;
        const particleGeom = new THREE.BufferGeometry();
        const particlePos = new Float32Array(particleCount * 3);
        for (let i = 0; i < particleCount; i++) {
            particlePos[i * 3] = (Math.random() - 0.5) * 20;
            particlePos[i * 3 + 1] = (Math.random() - 0.5) * 100 - 20;
            particlePos[i * 3 + 2] = (Math.random() - 0.5) * 10;
        }
        particleGeom.setAttribute('position', new THREE.BufferAttribute(particlePos, 3));
        const particleMat = new THREE.PointsMaterial({
            size: 0.03,
            color: 0x8b5cf6,
            transparent: true,
            opacity: 0.6
        });
        const particles = new THREE.Points(particleGeom, particleMat);
        scene.add(particles);

        // Scroll handling
        let scrollY = 0;
        let currentSection = 0;
        const sectionCount = 6;

        window.addEventListener('scroll', () => {
            scrollY = window.scrollY;
            const progress = scrollY / (document.body.scrollHeight - window.innerHeight);
            document.getElementById('progressBar').style.transform = `scaleX(${progress})`;

            // Hide scroll indicator after scrolling
            document.getElementById('scrollIndicator').style.opacity = scrollY > 100 ? '0' : '0.5';

            // Update visible sections
            document.querySelectorAll('section').forEach((section, i) => {
                const rect = section.getBoundingClientRect();
                if (rect.top < window.innerHeight * 0.75 && rect.bottom > 0) {
                    section.classList.add('visible');
                }
            });
        });

        // Animation
        const clock = new THREE.Clock();
        function animate() {
            const t = clock.getElapsedTime();
            const scrollProgress = scrollY / (document.body.scrollHeight - window.innerHeight);

            // Move camera based on scroll
            camera.position.y = -scrollProgress * 40;

            // Animate objects
            objects.forEach((obj, i) => {
                const mesh = obj.mesh;

                // Float animation
                mesh.position.y = obj.baseY + Math.sin(t + i) * 0.3;

                // Rotation
                mesh.rotation.y = t * 0.3 + i;
                mesh.rotation.x = Math.sin(t * 0.5 + i) * 0.2;

                // Scale based on visibility
                const distFromCamera = Math.abs(mesh.position.y - camera.position.y);
                const scale = Math.max(0.5, 1 - distFromCamera * 0.05);
                mesh.scale.setScalar(scale);
            });

            // Animate particles
            particles.rotation.y = t * 0.02;
            particles.position.y = -scrollProgress * 40;

            // Animate lights
            light1.position.y = Math.sin(t) * 5 + camera.position.y;
            light2.position.y = Math.cos(t) * 5 + camera.position.y;

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        animate();

        // Initial visibility
        document.querySelector('section').classList.add('visible');

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
