<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Morphing Logo - Purple Squirrel Media</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            overflow: hidden;
            background: #0a0a0f;
            font-family: 'Segoe UI', system-ui, sans-serif;
        }
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1;
        }
        .content {
            position: relative;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            color: white;
            text-align: center;
            pointer-events: none;
        }
        .tagline {
            font-size: 1.5rem;
            color: rgba(255,255,255,0.6);
            margin-top: 2rem;
            opacity: 0;
            animation: fadeIn 1s ease 2s forwards;
        }
        @keyframes fadeIn {
            to { opacity: 1; }
        }
        .controls {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 1rem;
            z-index: 20;
        }
        .shape-btn {
            background: rgba(139, 92, 246, 0.2);
            border: 1px solid rgba(139, 92, 246, 0.5);
            color: #a78bfa;
            padding: 0.75rem 1.5rem;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }
        .shape-btn:hover, .shape-btn.active {
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
            color: white;
            border-color: transparent;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="content">
        <p class="tagline">Stream. Own. Experience.</p>
    </div>

    <div class="controls">
        <button class="shape-btn active" data-shape="sphere">Sphere</button>
        <button class="shape-btn" data-shape="torus">Torus</button>
        <button class="shape-btn" data-shape="box">Cube</button>
        <button class="shape-btn" data-shape="knot">Knot</button>
        <button class="shape-btn" data-shape="text">PSM</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const canvas = document.getElementById('canvas');
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 4;

        // Particle count
        const particleCount = 15000;

        // Create geometries for different shapes
        const geometries = {
            sphere: new THREE.SphereGeometry(1.5, 64, 64),
            torus: new THREE.TorusGeometry(1.2, 0.5, 32, 100),
            box: new THREE.BoxGeometry(2, 2, 2, 20, 20, 20),
            knot: new THREE.TorusKnotGeometry(1, 0.3, 128, 32),
            text: createTextGeometry()
        };

        function createTextGeometry() {
            // Create PSM using basic shapes arranged as letters
            const group = new THREE.BufferGeometry();
            const positions = [];

            // P
            for (let i = 0; i < 500; i++) {
                positions.push(-1.5 + Math.random() * 0.1, -1 + Math.random() * 2, Math.random() * 0.1);
            }
            for (let i = 0; i < 300; i++) {
                positions.push(-1.5 + Math.random() * 0.8, 0.8 + Math.random() * 0.2, Math.random() * 0.1);
            }
            for (let i = 0; i < 300; i++) {
                positions.push(-0.7 + Math.random() * 0.1, 0.2 + Math.random() * 0.8, Math.random() * 0.1);
            }
            for (let i = 0; i < 200; i++) {
                positions.push(-1.5 + Math.random() * 0.8, 0 + Math.random() * 0.2, Math.random() * 0.1);
            }

            // S
            for (let i = 0; i < 800; i++) {
                const t = i / 800;
                const x = 0 + Math.sin(t * Math.PI * 2) * 0.4;
                const y = -1 + t * 2;
                positions.push(x + Math.random() * 0.1, y, Math.random() * 0.1);
            }

            // M
            for (let i = 0; i < 400; i++) {
                positions.push(1 + Math.random() * 0.1, -1 + Math.random() * 2, Math.random() * 0.1);
            }
            for (let i = 0; i < 300; i++) {
                const t = i / 300;
                positions.push(1 + t * 0.4, 1 - t * 1, Math.random() * 0.1);
            }
            for (let i = 0; i < 300; i++) {
                const t = i / 300;
                positions.push(1.4 + t * 0.4, t * 1, Math.random() * 0.1);
            }
            for (let i = 0; i < 400; i++) {
                positions.push(1.8 + Math.random() * 0.1, -1 + Math.random() * 2, Math.random() * 0.1);
            }

            group.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            return group;
        }

        // Get positions from geometry
        function getPositions(geometry) {
            const positions = [];
            const pos = geometry.attributes.position;

            if (geometry.type === 'BufferGeometry' && !geometry.index) {
                // Direct buffer geometry (like our text)
                for (let i = 0; i < pos.count && positions.length < particleCount * 3; i++) {
                    positions.push(pos.getX(i), pos.getY(i), pos.getZ(i));
                }
            } else {
                // Sample from surface
                const tempPos = geometry.attributes.position;
                for (let i = 0; i < particleCount; i++) {
                    const idx = Math.floor(Math.random() * tempPos.count);
                    positions.push(
                        tempPos.getX(idx) + (Math.random() - 0.5) * 0.02,
                        tempPos.getY(idx) + (Math.random() - 0.5) * 0.02,
                        tempPos.getZ(idx) + (Math.random() - 0.5) * 0.02
                    );
                }
            }

            // Fill remaining with random positions near center
            while (positions.length < particleCount * 3) {
                positions.push(
                    (Math.random() - 0.5) * 3,
                    (Math.random() - 0.5) * 3,
                    (Math.random() - 0.5) * 0.5
                );
            }

            return new Float32Array(positions.slice(0, particleCount * 3));
        }

        // Create particles
        const particleGeometry = new THREE.BufferGeometry();
        let currentPositions = getPositions(geometries.sphere);
        let targetPositions = currentPositions.slice();

        particleGeometry.setAttribute('position', new THREE.BufferAttribute(currentPositions, 3));

        // Create colors
        const colors = new Float32Array(particleCount * 3);
        const color1 = new THREE.Color(0x8b5cf6);
        const color2 = new THREE.Color(0xd946ef);
        const color3 = new THREE.Color(0x06b6d4);

        for (let i = 0; i < particleCount; i++) {
            const t = Math.random();
            const mixedColor = t < 0.5
                ? color1.clone().lerp(color2, t * 2)
                : color2.clone().lerp(color3, (t - 0.5) * 2);
            colors[i * 3] = mixedColor.r;
            colors[i * 3 + 1] = mixedColor.g;
            colors[i * 3 + 2] = mixedColor.b;
        }
        particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const particleMaterial = new THREE.PointsMaterial({
            size: 0.02,
            vertexColors: true,
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const particles = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(particles);

        // Morph animation state
        let morphProgress = 1;
        let isAnimating = false;

        function morphTo(shapeName) {
            if (isAnimating) return;

            targetPositions = getPositions(geometries[shapeName]);
            morphProgress = 0;
            isAnimating = true;

            // Update active button
            document.querySelectorAll('.shape-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.shape === shapeName);
            });
        }

        // Button handlers
        document.querySelectorAll('.shape-btn').forEach(btn => {
            btn.addEventListener('click', () => morphTo(btn.dataset.shape));
        });

        // Mouse interaction
        const mouse = { x: 0, y: 0 };
        document.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        });

        // Animation
        const clock = new THREE.Clock();
        function animate() {
            const t = clock.getElapsedTime();
            const positions = particleGeometry.attributes.position.array;

            // Morph animation
            if (morphProgress < 1) {
                morphProgress += 0.02;
                if (morphProgress >= 1) {
                    morphProgress = 1;
                    isAnimating = false;
                }

                // Easing function
                const ease = morphProgress < 0.5
                    ? 4 * morphProgress * morphProgress * morphProgress
                    : 1 - Math.pow(-2 * morphProgress + 2, 3) / 2;

                for (let i = 0; i < particleCount * 3; i++) {
                    const current = currentPositions[i];
                    const target = targetPositions[i];
                    positions[i] = current + (target - current) * ease;
                }
            }

            // Update current positions when morph complete
            if (morphProgress >= 1 && isAnimating === false) {
                currentPositions = positions.slice();
            }

            // Add floating motion
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const originalX = morphProgress >= 1 ? targetPositions[i3] : positions[i3];
                const originalY = morphProgress >= 1 ? targetPositions[i3 + 1] : positions[i3 + 1];

                if (morphProgress >= 1) {
                    positions[i3] = originalX + Math.sin(t + i * 0.01) * 0.01;
                    positions[i3 + 1] = originalY + Math.cos(t + i * 0.01) * 0.01;
                }
            }

            particleGeometry.attributes.position.needsUpdate = true;

            // Rotate based on mouse
            particles.rotation.y = mouse.x * 0.5 + t * 0.1;
            particles.rotation.x = mouse.y * 0.3;

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        animate();

        // Auto-cycle through shapes
        let shapeIndex = 0;
        const shapes = ['sphere', 'torus', 'box', 'knot', 'text'];
        setInterval(() => {
            shapeIndex = (shapeIndex + 1) % shapes.length;
            morphTo(shapes[shapeIndex]);
        }, 4000);

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
